<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal CNC Spindle Motor Controller: routerInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Universal CNC Spindle Motor Controller
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">Interfaces Standard 110v routers with a Stm32 Nucleo Microcontroller</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrouterInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">routerInterface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class definition for router interface.  
 <a href="classrouterInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="userInterface_8h_source.html">userInterface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c6a1be9c6422f10ced3f7621245abae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#a3c6a1be9c6422f10ced3f7621245abae">routerInterface</a> (bool init)</td></tr>
<tr class="memdesc:a3c6a1be9c6422f10ced3f7621245abae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that constructs an interface object.  <a href="classrouterInterface.html#a3c6a1be9c6422f10ced3f7621245abae">More...</a><br /></td></tr>
<tr class="separator:a3c6a1be9c6422f10ced3f7621245abae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f17ea1af7a9a8d4868af28c36bfdf59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#a3f17ea1af7a9a8d4868af28c36bfdf59">refresh</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:a3f17ea1af7a9a8d4868af28c36bfdf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that is called in precise intervals by the user interface task to refresh the display.  <a href="classrouterInterface.html#a3f17ea1af7a9a8d4868af28c36bfdf59">More...</a><br /></td></tr>
<tr class="separator:a3f17ea1af7a9a8d4868af28c36bfdf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b887af01346e188e6c6bf7d1481763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#ab7b887af01346e188e6c6bf7d1481763">managePress</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:ab7b887af01346e188e6c6bf7d1481763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that updates the display based on when the encoder was pressed.  <a href="classrouterInterface.html#ab7b887af01346e188e6c6bf7d1481763">More...</a><br /></td></tr>
<tr class="separator:ab7b887af01346e188e6c6bf7d1481763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f96a1c8bf175e0882159280ca956f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#ae8f96a1c8bf175e0882159280ca956f4">manageSet</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:ae8f96a1c8bf175e0882159280ca956f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the user interface FSM after the user has pressed the "Set" button.  <a href="classrouterInterface.html#ae8f96a1c8bf175e0882159280ca956f4">More...</a><br /></td></tr>
<tr class="separator:ae8f96a1c8bf175e0882159280ca956f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e0fb158a5633f41d7d87fafdb8e555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#a83e0fb158a5633f41d7d87fafdb8e555">manageView</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:a83e0fb158a5633f41d7d87fafdb8e555"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the user interface FSM when the user is viewing the current measured RPM.  <a href="classrouterInterface.html#a83e0fb158a5633f41d7d87fafdb8e555">More...</a><br /></td></tr>
<tr class="separator:a83e0fb158a5633f41d7d87fafdb8e555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9640508686b67e5d8893909990bd40cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#a9640508686b67e5d8893909990bd40cf">manageSpin</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:a9640508686b67e5d8893909990bd40cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the user interface FSM when nothing has been selected yet.  <a href="classrouterInterface.html#a9640508686b67e5d8893909990bd40cf">More...</a><br /></td></tr>
<tr class="separator:a9640508686b67e5d8893909990bd40cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad893706c6f5d5148d2496daf2dea46df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#ad893706c6f5d5148d2496daf2dea46df">manageRes</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:ad893706c6f5d5148d2496daf2dea46df"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the user interface FSM when the resolution is being adjusted.  <a href="classrouterInterface.html#ad893706c6f5d5148d2496daf2dea46df">More...</a><br /></td></tr>
<tr class="separator:ad893706c6f5d5148d2496daf2dea46df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40b23a48f6e13ca12f4160de51b9a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrouterInterface.html#af40b23a48f6e13ca12f4160de51b9a44">manageSpeed</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder)</td></tr>
<tr class="memdesc:af40b23a48f6e13ca12f4160de51b9a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the user interface FSM when the speed set point is being adjusted.  <a href="classrouterInterface.html#af40b23a48f6e13ca12f4160de51b9a44">More...</a><br /></td></tr>
<tr class="separator:af40b23a48f6e13ca12f4160de51b9a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab6707eec739db7e6904a6d0dd32a158d"><td class="memItemLeft" align="right" valign="top"><a id="ab6707eec739db7e6904a6d0dd32a158d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentSP</b></td></tr>
<tr class="separator:ab6707eec739db7e6904a6d0dd32a158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a73a283ea2f0c6d176814f770960e2436"><td class="memItemLeft" align="right" valign="top"><a id="a73a283ea2f0c6d176814f770960e2436"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>page_state</b></td></tr>
<tr class="separator:a73a283ea2f0c6d176814f770960e2436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc9b1026a6c089edf7a4d38fc8f1ff"><td class="memItemLeft" align="right" valign="top"><a id="a20cc9b1026a6c089edf7a4d38fc8f1ff"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>button_state</b></td></tr>
<tr class="separator:a20cc9b1026a6c089edf7a4d38fc8f1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737349052bf764af59d285c36d1589dc"><td class="memItemLeft" align="right" valign="top"><a id="a737349052bf764af59d285c36d1589dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>static_disp_done</b></td></tr>
<tr class="separator:a737349052bf764af59d285c36d1589dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc2761ccaab5b4730e687e4af1a4e03"><td class="memItemLeft" align="right" valign="top"><a id="a5dc2761ccaab5b4730e687e4af1a4e03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>selected</b></td></tr>
<tr class="separator:a5dc2761ccaab5b4730e687e4af1a4e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31642296af3bf0dbcf78e254b26f8f6"><td class="memItemLeft" align="right" valign="top"><a id="ae31642296af3bf0dbcf78e254b26f8f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>settingSpeed</b></td></tr>
<tr class="separator:ae31642296af3bf0dbcf78e254b26f8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f286202d6713a3a771ed0c95641cb7"><td class="memItemLeft" align="right" valign="top"><a id="ab3f286202d6713a3a771ed0c95641cb7"></a>
<a class="el" href="classscreenButton.html">screenButton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>SET</b></td></tr>
<tr class="separator:ab3f286202d6713a3a771ed0c95641cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae359d2db6c9a1f26b6bed67a4f486d"><td class="memItemLeft" align="right" valign="top"><a id="a1ae359d2db6c9a1f26b6bed67a4f486d"></a>
<a class="el" href="classscreenButton.html">screenButton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>VIEW</b></td></tr>
<tr class="separator:a1ae359d2db6c9a1f26b6bed67a4f486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace2a9dc7a9e6b7b0d34d1868260d377"><td class="memItemLeft" align="right" valign="top"><a id="aace2a9dc7a9e6b7b0d34d1868260d377"></a>
<a class="el" href="classscreenButton.html">screenButton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RES</b></td></tr>
<tr class="separator:aace2a9dc7a9e6b7b0d34d1868260d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb52d86c10ab894b01353c960fb617bb"><td class="memItemLeft" align="right" valign="top"><a id="aeb52d86c10ab894b01353c960fb617bb"></a>
<a class="el" href="classscreenButton.html">screenButton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>SPEED</b></td></tr>
<tr class="separator:aeb52d86c10ab894b01353c960fb617bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635c31f16ba0bff0f01a3f13fb6ea102"><td class="memItemLeft" align="right" valign="top"><a id="a635c31f16ba0bff0f01a3f13fb6ea102"></a>
<a class="el" href="classscreenButton.html">screenButton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MES</b></td></tr>
<tr class="separator:a635c31f16ba0bff0f01a3f13fb6ea102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aac015b18876483248c480bc213e51"><td class="memItemLeft" align="right" valign="top"><a id="a06aac015b18876483248c480bc213e51"></a>
Adafruit_SSD1306 *&#160;</td><td class="memItemRight" valign="bottom"><b>display</b></td></tr>
<tr class="separator:a06aac015b18876483248c480bc213e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class definition for router interface. </p>
<p>Although we need to create a display object, it is helpful to have a separate object to store attributes unique to this particular user interface. This includes display flags such as <code>selected</code>, <code>static_disp_done</code>, and <code>setting</code> speed. Having all of this encapsulated in a class allows us to implement multiple types of interfaces for the same display object. Let's say we want one "front end" interface for changing the speed RPM set point and reading the current measured sped, but we want a second, unique, "back end" interface for adjusting PID constants and debugging errors with the controller. Then we can make a second interface object and switch off between the two. This would also be useful if we wanted to incorporate another I2C screen. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3c6a1be9c6422f10ced3f7621245abae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6a1be9c6422f10ced3f7621245abae">&#9670;&nbsp;</a></span>routerInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">routerInterface::routerInterface </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that constructs an interface object. </p>
<p>This function creates an instance of our interface and sets default values. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab7b887af01346e188e6c6bf7d1481763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b887af01346e188e6c6bf7d1481763">&#9670;&nbsp;</a></span>managePress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::managePress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that updates the display based on when the encoder was pressed. </p>
<p>Whenever the encoder is pressed, it raises a boolean flag telling the interface that it was pressed, and an action needs to be taken. The interface lowers this flag after it has been dealt with. The response of the interface to a button press depends on what display state we are currently in. This function checks which state we're in, and then updates the objects currently on-display accordingly, based on the press. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad893706c6f5d5148d2496daf2dea46df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad893706c6f5d5148d2496daf2dea46df">&#9670;&nbsp;</a></span>manageRes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::manageRes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the user interface FSM when the resolution is being adjusted. </p>
<p>This state does not update the actual resolution of the encoder. Rather, it updates the text on the screen with a resolution option. The user toggles through four possible encoder resolutions: 1, 10, 100, 1000, using the encoder, and the resolution is updated upon deselecting the RES button. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8f96a1c8bf175e0882159280ca956f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f96a1c8bf175e0882159280ca956f4">&#9670;&nbsp;</a></span>manageSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::manageSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the user interface FSM after the user has pressed the "Set" button. </p>
<p>When the user selects the "Set" button, they now have several options. They can either press the Set or View button again to unselect it, or they can select the "Res" or "Speed" button to change the resolution of the encoder or change the speed set point. Because we're using the same encoder to toggle through options and to adjust the speed, we need to make this this code more general. Deciding which button is currently being hovered/selected is determined by multiples of the encoder's resolution. This lets us store the encoder resolution and not worry about it being erased. As an example, the user sets the encoder resolution to 10, meaning that they want to adjust the speed set point in increments of 10. When they return to this state, as they twist the encoder to select another option on the screen, the encoder's count will continue to increase or decrease by 10. In this state, the SET button will always be pressed. Therefore, its appearance on the display will never need to be updated, as it is static. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af40b23a48f6e13ca12f4160de51b9a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40b23a48f6e13ca12f4160de51b9a44">&#9670;&nbsp;</a></span>manageSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::manageSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the user interface FSM when the speed set point is being adjusted. </p>
<p>This function updates the text that displays the speed set point. Note that it doesn't actually update the speed set point, it only updates the text on the screen. It does this by updating the text attribute of the SPEED button object, and then raising its "refresh" flag, indicating that the button needs to be updated on the screen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9640508686b67e5d8893909990bd40cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9640508686b67e5d8893909990bd40cf">&#9670;&nbsp;</a></span>manageSpin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::manageSpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the user interface FSM when nothing has been selected yet. </p>
<p>When nothing has been selected, the user can only choose between two options that are displayed on the screen, SET and VIEW. When nothing is selected, the maximum encoder count value is constrained to 1x resolution, so the encoder count can either be 0, or the resolution. This state updates both buttons with which one is being hovered over while the user uses the encoder to toggle through the two options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83e0fb158a5633f41d7d87fafdb8e555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e0fb158a5633f41d7d87fafdb8e555">&#9670;&nbsp;</a></span>manageView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::manageView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State of the user interface FSM when the user is viewing the current measured RPM. </p>
<p>The user interface enters this state when the user selects "View" on the display. Here, the current measured RPM of the motor is displayed, along with the current set point. To display the current speed, it retreives the current speed from the queue, and updates the text attribute of the MES button object with the current speed. Since the speed set point will never change in this state, it does not need to be updated here, as it is static. Finally, the state raises the button's "refresh" flag, indicating that it needs to be updated on the screen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f17ea1af7a9a8d4868af28c36bfdf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f17ea1af7a9a8d4868af28c36bfdf59">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void routerInterface::refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that is called in precise intervals by the user interface task to refresh the display. </p>
<p>This function updates the display using a state machine. There are 5 possible display states. The user can either be: choosing whether to adjust the resolution or speed, viewing the current measured speed, adjusting the resolution, adjusting the speed, or neutral. First, this function updates all button objects. Not every button is displayed on the screen at any given time, so many of these update() calls will return 0; only the buttons that are not "off", are refreshed. Next, the function checks if the encoder has been pressed. Because the user can press the encoder to provide input to the interface, the screen needs to refresh accordingly based on when the encoder was pressed. Handling the pressing of the encoder is nearly a state machine in itself. Finally, the function runs the code that corresponds to our display state. The state variable is stored in the variable <code>button_state</code> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>The encoder object that we're using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="userInterface_8h_source.html">userInterface.h</a></li>
<li><a class="el" href="userInterface_8cpp.html">userInterface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
